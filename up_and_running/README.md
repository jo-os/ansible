
# Ansible: Up and Running

- Откуда взялось название «Ansible»?

Название заимствовано из области научной фантастики. Ansible – это устройство связи, способное передавать информацию быстрее скорости света. Майкл ДеХаан, сооснователь проек- та, позаимствовал название Ansible из книги Орсона Скотта Карда «Игра Эндера».

### Ansible: область применения
- Ansible часто описывают как инструмент управления конфигурациями - принимаем как описание состояния серверов в некотором виде, а затем применение специальных средств для приведения серверов в это состояние. Ansible предоставляет предметно-ориентированный язык (Domain Specific Language, DSL), который используется для описания состояний серверов.
- Подготовка и наполнение новых серверов - подразумевается развертывание новых экземпляров виртуальной машины или облачных служб «программное обеспечение как услуга». Ansible охватывает и эту область, предоставляя несколько модулей поддержки облаков.
## Какие преимущества дает Ansible?
- Простота - Разработчики стремились максимально упростить процесс установ- ки и освоение Ansible
  - Простота синтаксиса - Фактически синтаксис сценариев Ansible основан на YAML, языке описания данных, который создавался специально, чтобы легко восприниматься человеком.
  - Простота аудита - можно легко получить список всех действий и вовлеченных хостов - ansible-playbook --check
  - Практически ничего не нужно устанавливать на удаленных хостаx - Linux должна быть установлена поддержка SSH и Python, Windows должен быть включен WinRM
  - Возможность масштабирования вниз - простое должно оставаться простым, а сложное – возможным
  - Простота распространения - Основной единицей повторного использования в сообществе Ansible в настоящее время является коллекция
  - Простота абстракций - Ansible работает с простыми абстракциями системных ресурсов, таких как файлы, каталоги, пользователи, группы, службы, пакеты и веб-сервисы
  - Выполнение задач сверху вниз - Модули Ansible устроены так, что единственный запуск сценария Ansible сразу приводит каждый сервер в желаемое состояние
 
- Широта возможностей - Абстракции высокого уров- ня, предоставляемые Ansible (например, роли), дают возможность устанавливать и настраивать программное обеспечение быстрее и по- тенциально безопаснее.
  - Встроенные модули - сильной стороной является набор встроенных модулей - модули Ansible несут декларативную функцию и используются для описания требуемого состояния серверов.
  - Использование технологии принудительной настройки - Принудительная настройка дает важное преимущество – вы контролируете время обновления серверов.
  - Многоуровневая оркестрация - Технология принудительной настройки позволяет также реализовать с помощью Ansible многоуровневую оркестрацию – управление отдельными группами компьютеров для выполнения различных операций, таких как обновление ПО.
  - Отсутствие ведущего узла - Ansible официально поддерживает особый режим, называемый ansible-pull, в котором сценарии извлекаются из репозитория. Ansible не нуждается в ведущем узле.
  - Поддержка плагинов - Значительная часть функциональности Ansible реализована в виде подключаемых модулей – плагинов, из которых наиболее часто используются плагины Lookup и Filter. Плагины расширяют базовые возможности Ansible логикой и функциями.
  - Настоящая масштабируемость - Крупные предприятия успешно используют Ansible для настройки десятков тысяч узлов и отлично поддерживают окружения, в которых серверы появляются и исчезают динамически.

- Защищенность - Автоматизация с помощью Ansible помогает повысить защищенность системы до базовых уровней безопасности и стандартов соответствия.
  - Самодокументирующийся код - сценарии всегда содержат актуальные инструкции, поскольку сами являются выполняемым кодом
  - Воспроизводимость - тестирование десятым этажом
  - Эквивалентность создаваемых окружений - Ansible поддерживает определенный способ организации контента, помогающий определить конфигурацию на надлежащем уровне.
  - Шифрование переменных - ansible-vault
  - Защищенный транспорт - Ansible просто использует Secure Shell (SSH) для Linux и WinRM для Windows.
  - Идемпотентность - Идемпотентность – заме- чательное свойство и означает, что сценарий Ansible можно применить к одному и тому же серверу много раз без всякого ущерба для конфи- гурации последнего.
  - Отсутствие демонов - В Ansible нет агента, прослушивающего некоторый порт.
 
### ansible.cfg
ansible.cfg - определяет местоположение файла реестра (inventory) и параметры, влияющие на работу Ansible, например на форматирование вывода.

Где лучше хранить файл ansible.cfg?
- файл, указанный в переменной окружения ANSIBLE_ CONFIG;
- ./ansible.cfg (ansible.cfg в текущем каталоге);
- ~/.ansible.cfg(.ansible.cfg в вашем домашнем каталоге);
- /etc/ansible/ansible.cfg(Linux)или/usr/local/etc/ansible/ansible.cfg

С настройками по умолчанию можно запускать Ansible без ключа –i с именем хоста:
```
ansible testserver -m ping
```
Произвольные команды можно выполнять с помощью модуля command. При запуске модуля необходимо указать аргумент -a с запускаемой командой.
```
ansible testserver -m command -a uptime
```
Модуль command используется настолько часто, что его имя можно опустить в команде
```
ansible testserver -a uptime
```
Если команда в аргументе -a содержит пробелы, то ее необходимо заключить в кавычки
```
ansible testserver -a "tail /var/log/dmesg"
```
Чтобы выполнить команду с привилегиями root, нужно передать параметр –b или --become. В этом случае Ansible выполнит команду от лица (become) пользователя root
```
ansible testserver -b -a "tail /var/log/syslog"
```
## Сценарии: начало
Сценарием (playbook) в Ansible называется файл, описывающий порядок управления конфигурациями.
```
ansible-inventory --graph   - проверим группы в реестре
ansible-playbook webservers.yml - запуск сценария
```
В соответствии с соглашениями Ansible копирует файлы из каталога files, а шаблоны Jinja2 ищет в подкаталоге templates. Поиск в этих ката- логах система Ansible выполняет автоматически.

Сценарии пишутся на YAML - все сценарии Ansible пишутся на YAML. YAML – это язык разметки, напоминающий JSON, но намного проще для восприятия человеком.
```
--- - Начало файла
... - Конец файла
#  - Это комментарий на языке YAML
```
В документах YAML принято оформлять отступы пробелами, чтобы уменьшить количество знаков пунктуации. Мы используем два пробела. А для большей удобочитаемости мы предпочитаем добавлять пробельные строки между задачами в сценарии и между разделами в файлах.
- истина в YAML: true, True, TRUE, yes, Yes, YES, on, On, ON
- ложь в YAML: false, False, FALSE, no, No, NO, off, Off, OFF

**Списки** - в YAML они называются последовательностями. Списки оформляются с помощью отступов и дефиса. Определение каждого списка начинается с его имени и следующего за ним двоеточия. YAML также поддерживает формат встроенных списков. Такие списки заключаются в квадратные скобки, а элементы списка разделяются запятой
```
shows:
- My Fair Lady
- Oklahoma
- The Pirates of Penzance
=
shows: [ My Fair Lady , Oklahoma , The Pirates of Penzance ]
```
**Словари** - в YAML они называются отображениями. YAML также поддерживает формат встроенных словарей. Такие словари заключаются в фигурные скобки, а элементы словаря разделяются запятой.
```
address:
street: Main Street
appt: 742
city: Logan
=
address: { street: Main Street, appt: '742', city: Logan}
```
**Многострочные строковые значения**
YAML поддерживает многострочные строковые значения, распознавая так называемые операторные скобки (| и >) символы, обозначающие начало многострочного текста (+ и –), и даже отступы (от 1 до 9)
```
visiting_address: |+
Department of Computer Science
A.V. Williams Building
University of Maryland
```
**Чистый YAML** - стиль, принятый в YAML можно проанализировать с помощью yamllint
```
- name: Ensure nginx is installed
  package:
    name: nginx
    update_cache: true
```
**Операции** - В любом формате – YAML или JSON – сценарий является списком словарей, или списком операций (play)
- Каждая операция должна содержать переменную hosts, определяющую список хостов или группу
- Воспринимайте операцию как нечто, связывающее хосты и задачи
- Кроме хостов и задач, операции также могут содержать параметры

Три основных параметра
- name - Комментарий, описывающий операцию. Ansible выведет его перед запуском операции.
- become - true, то Ansible выполнит каждую задачу, предварительно приобретя привилегии пользователя, объявленного в параметре become_user
- vars - Список переменных и значений

**Задачи** - tasks - модуль + аргументы = ведет к получению определенного результата

Флаг --start-at-task <имя задачи>,чтобы с помощью ansible-playbook запустить сценарий с середины операции. В этом случае необходимо сослаться на задачу по имени.

**Модули** – это сценарии, которые поставляются с Ansible и производят определенные действия на хосте. Ansible выполняет задачу на хосте, генерируя сценарий, исходя из имени модуля и аргументов, а затем копирует этот сценарий на хост и запускает его.

- package - Устанавливает или удаляет пакеты с использованием диспетчера пакетов хоста.
- copy - Копирует файл с локальной машины на хосты.
- file - Устанавливает атрибуты файла, символической ссылки или каталога
- service - Запускает, останавливает или перезапускает службу.
- template - Создает файл на основе шаблона и копирует его на хосты

**Документация по модулям Ansible**
```
ansible-doc service - вывода документации к модулю service
ansible-doc -l | grep ^apt - найти более конкретные модули, связанные с диспетчером пакетов apt
```
Итог
- **Сценарий** содержит одну или несколько операций.
- **Операции** назначаются неупорядоченному множеству хостов и содержат упорядоченные списки задач.
- Каждая **задача** использует ровно один **модуль**.

**Отслеживание состояния хоста**

Если состояние хоста соответствует значениям аргументов модуля, то Ansible не предпринимает никаких действий и сообщает, что статус **ok**. Если между состоянием хоста и значениями аргументов модуля есть разница, то Ansible вносит изменения в состояние хоста и сообщает, что статус был изменен **(changed)**. Способность Ansible определять изменение состояния можно использовать для выполнения дополни- тельных действий с помощью обработчиков.

**Переменные**
```
vars:
tls_dir: /etc/nginx/ssl/
key_file: nginx.key
cert_file: nginx.crt
```
Каждое значение – это строка. Вообще значением переменной может служить любое выражение, допустимое в YAML. В дополнение к строкам и булевым выражениям можно использовать списки и словари. Для ссылки на переменные используются скобки, например **{{ mustache }}**

**Когда использовать кавычки в строках Ansible**
- Если ссылка на переменную следует сразу после имени модуля, то парсер YAML ошибочно воспримет ее как начало встроенного словаря.
- Похожая ошибка возникает при наличии двоеточия в аргументе. Двоеточие в аргументе сбивает с толку синтаксический анализатор YAM

Ansible поддерживает чередование одинарных и двойных кавычек

**Создание шаблона**

Шаблон – это простой текстовый файл, где с использо- ванием специального синтаксиса определяются переменные, которые должны заменяться фактическими значениями.

Для поддержки шаблонов в Ansible используется механизм Jinja2.

**Циклы**

Если потребуется запустить задачу для каждого элемента из списка, то для этого можно использовать цикл loop. Цикл выполняет задачу несколько раз, каждый раз заменяя элемент item разными значениями из указанного списка
```
- name: Copy TLS files
  copy:
    src: "{{ item }}"
    dest: "{{ tls_dir }}"
    mode: '0600'
  loop:
    - "{{ key_file }}"
    - "{{ cert_file }}"

```
**Обработчики**

Обработчики – это одна из форм условного выполнения, поддерживаемых в Ansible. Обработчик схож с задачей, но запускается только после получения уведомления от задачи.
```
notify: Restart nginx
```
Добавляем инструкцию notify в каждую задачу, чтобы обеспечить перезапуск NGINX, если выполняется одно из условий.

**Несколько фактов об обработчиках, которые необходимо помнить**
- Обработчики обычно выполняются после завершения всех задач и только один раз, даже если было получено несколько уведомлений. Чтобы запустить обработчик в середине операции, нужно добавить следующие две строки:
```
- name: Restart nginx
  meta: flush_handlers
```
- Если сценарий содержит несколько обработчиков, то они всегда выполняются в порядке следования в разделе handlers, а не в порядке поступления уведомлений.
- В официальной документации Ansible говорится, что обработчики в основном используются для перезапуска служб и перезагрузки. 

**Проверка**

**ansible-lint** – это инструмент на языке Python, помогающий находить потенциальные проблемы в сценариях.

Провека синтаксиса:
```
ansible-playbook --syntax-check webservers-tls.yml
ansible-lint webservers-tls.yml
yamllint webservers-tls.yml
```

## Реестр: описание серверов

Реестр в простейшем виде – это список имен хостов, перечисленных через запятую
```
ansible all -i 'localhost,' -a date
```
Группа хостов, данными о которых располагает Ansible, называется реестром (inventory)

**Реестр Ansible** – очень гибкий объект: это может быть текстовый файл, каталог или выполняемый файл, причем некоторые выполняемые файлы поставляются в виде плагинов. Плагины поддержки реестра позволяют указать источник данных, например поставщика облачных услуг, для составления реестра.

**Файл реестра**

Самый простой способ описать имеющиеся хосты – перечислить их в текстовом файле, который принято называть файлом реестра хостов. В простейшем случае реестр – это файл host

**Поведенческие параметры хостов в реестре**

В файле реестра Ansible можно явно указать порт, к которому будет подключаться SSH-клиент системы Ansible. В Ansible эти переменные называются **поведенческими параметрами**
- ansible_host -  Имя хоста Имя хоста или IP-адрес
- ansible_port -  22 Порт для подключения по протоколу SSH
- ansible_user - $USER Пользователь для подключения по прото- колу SSH
- ansible_password (нет) Пароль для подключения по протоколу SSH
- ansible_connection - smart Как Ansible будет подключаться к хосту
- ansible_ssh_private_key_file - (нет) - Закрытый SSH-ключ для аутентификации по протоколу SSH
- ansible_shell_type - sh - Командная оболочка для выполнения команд
- ansible_python_interpreter - /usr/bin/python - Путь к интерпретатору Python на хосте
- ansible_*_interpreter - (нет) - Аналоги ansible_python_interpreter для других языков

- **ansible_connection** - Ansible поддерживаетнесколькотранспортов–механизмовпод- ключения к хостам. По умолчанию используется транспорт smart. Он проверяет поддержку локальным SSH-клиентом функции Con- trolPersist. Если SSH-клиент поддерживает ее, то Ansible будет ис- пользовать локального SSH-клиента. Если локальный клиент не поддерживает ControlPersist, тогда транспорт smart будет использо- вать библиотеку SSH-клиента на Python с названием Paramiko.
- **ansible_shell_type** - Ansible устанавливает SSH-соединения с удаленными машинами и затем запускает на них сценарии. По умолчанию Ansible считает, что на удаленных машинах используется командная оболочка Bourne Shell, доступная как /bin/sh, и создает параметры команд- ной строки, соответствующие оболочке Bourne Shell.
- **ansible_python_interpreter** - Ansible должна знать местоположение интерпретатора Python на удаленной машине.

**Переопределение значений по умолчанию в поведенческих параметрах**
- Переопределить значения по умолчанию поведенческих параметров можно в секции [defaults] файла ansible.cfg
- ansible_port - remote_port
- ansible_user - remote_user
- ansible_ssh_private_key_file - ssh_private_key_file
- ansible_shell_type - executable

Параметр executable определяет полный путь к используемой командной оболочке на удаленной ма- шине (например, /usr/local/bin/fish). Ansible выбирает имя в конце этого пути (для /usr/local/bin/fish это будет имя fish) и использует его как значение по умолчанию для ansible_shell_type

**Группы**

Ansible автоматически определяет группу all (или *). Она включает все хосты, перечисленные в реестре. Порядок следования групп не имеет значения, главный критерий – удобочитаемость.

**Псевдонимы и порты**
```
[vagrant]
vagrant1 ansible_port=2222
vagrant2 ansible_port=2200
```
Имена vagrant1, vagrant2, vagrant3 – это псевдонимы. Они не настоящие имена серверов, но их удобно использовать для обозначения хостов. Ansible поддерживает синтаксис <hostname>:<port>.

**Группировка групп**

Ansible позволяет также определять группы, состоящие из других групп. 
```
[django:children]
```
**Имена хостов с номерами**
```
[web]
web[1:20].example.com
```
**Переменные хостов и групп**
```
[all:vars]
...
[staging:vars]
...
```
Переменные групп объединяются в секции с именами [<имя группы>:vars].

**Переменные хостов и групп: создание собственных файлов**

Ansible проверяет наличие файлов переменных хостов в каталоге host_vars и файлов переменных групп в каталоге group_vars. Эти каталоги должны находиться в каталоге со сценарием или в каталоге с реестром. Если имеются оба каталога, то каталог со сценарием просматривается первым, а каталог с реестром – вторым.

**Динамический реестр**

Ansible поддерживает функцию динамического реестра, которая позволяет избежать копирования. Если файл реестра отмечен как выполняемый, то Ansible будет интерпретировать его как сценарий динамического реестра и запускать его вместо чтения.

**Вывод списка членов групп**

Команда --list должна поддерживать вывод всех переменных всех хостов.

## Переменные и факты
Ansible не является полноценным языком программирования, но в ней присутствуют некоторые черты, присущие языкам программирования. Одна из таких черт – подстановка переменных.

- Самый простой способ определить переменную – поместить в сценарий секцию vars
- Ansible позволяет также распределить объявления переменных по нескольким файлам, использовав секцию vars_files
- Ansible позволяет определить переменные, связанные с хостами или группами, в файле реестра или в отдельных файлах, находящихся рядом с файлом реестра или сценарием. Файлы и каталоги в подкаталоге group_vars должны иметь имена, совпадающие с именами соответствующих им групп в файле реестра, а файлы в каталоге host_vars – с именами соответствующих им хостов

**Вывод значений переменных**

Модуль debug для вывода произвольного сообщения.
```
- debug: var=myvarname
```
Значения переменных можно объединять в двойных фигурных скоб- ках с помощью оператора тильды ~:
```
- name: Concatenate variables
  debug:
    msg: "The URL is https://{{ server_name ~'.'~ domain_name }}/"
```
**Регистрация переменных**

Все модули в Ansible возвращают результат в формате JSON. Чтобы сохранить этот результат, нужно создать зарегистрированную переменную при вызове модуля с помощью ключевого слова **register**.
```
register: login
```
Чтобы использовать переменную login, мы должны знать тип ее значения. Значением переменных, объявленных с помощью ключевого слова register, всегда является словарь. Простейший способ узнать, какие значения возвращает модуль, – зарегистрировать переменную и вывести ее содержимое с помощью модуля debug.

Иногда бывает желательно как-то обработать вывод задачи, потерпевшей ошибку. Однако если задача потерпела ошибку, то Ansible остановит ее выполнение, не дав возможности получить эту ошибку. Чтобы Ansible не останавливала работу после появления ошибки, можно использовать ключевое слово **ignore_errors**.
```
ignore_errors: true
```
Если вы собираетесь использовать зарегистрированные переменные в своих сценариях, то обязательно узнайте, что возвращается в них в обоих случаях – когда состояние хоста изменяется и когда оно не изменяется

**Факты**

На этапе сбора фактов (GATHERING FACTS) Ansible подключается к хосту и запрашивает у него всю информацию: аппаратную архитектуру, название операционной системы, IP-адреса, объем памяти и диска и др. Получить доступ ко всем этим данным можно через переменную **ansible_facts**. По умолчанию к некоторым фактам Ansible можно также обращаться как к переменным верхнего уровня, добавляя префикс ansible_.
```
ansible_facts.os_family
ansible_facts.distribution
ansible_facts.kernel
```
Ansible осуществляет сбор фактов с помощью специального модуля **setup**
```
ansible ubuntu -m setup   - выведет все факты
```
Ansible собирает большое количество фактов, модуль setup поддерживает параметр **filter**.
```
ansible all -m setup -a 'filter=ansible_all_ipv6_addresses'
```
**Локальные факты**

Ansible поддерживает также дополнительный механизм, позволя- ющий ассоциировать факты с хостом. Разместите один или несколько файлов на хосте в каталоге /etc/ansible/facts.d, и Ansible обнаружит их, если они отвечают любому из следующих требований:
- имеют формат .ini;
- имеют формат JSON;
- являются выполняемыми файлами, не принимающими аргумен- тов, и выводят результат в формате JSON в стандартный вывод.

Эти факты доступны в виде ключей особой переменной **ansible_local**.
```
ansible_local.example.book.title
```
**Использование модуля set_fact для задания новой переменной**

Ansible позволяет устанавливать факты в задачах с помощью модуля **set_fact**.
```
set_fact:
  nginx_state: "{{ ansible_facts.services.nginx.state }}"
```
**Встроенные переменные**

Ansible определяет несколько переменных, всегда доступных в сценариях.
- hostvars - Словарь, ключами которого являются имена хостов Ansible, а значениями – словари, отображающие имена переменных в их значения.
- inventory_hostname - Имя текущего хоста, как оно задано в Ansible.
- inventory_hostname_short - Имя текущего хоста, как оно задано в Ansible, без имени домена
- group_names - Список всех групп, в которые входит текущий хост
- groups - Словарь, ключи которого – имена групп в Ansible, а значения – списки имен хостов
- ansible_check_mode - Логическая переменная = истинное значение, когда сценарий выполняется в режиме проверки
- ansible_play_batch - Логическая переменная = истинное значение, когда сценарий выполняется в тестовом режиме
- ansible_play_hosts - Список имен хостов из реестра, участвующих в текущей операции
- ansible_version - Словарь с информацией о версии Ansible

**hostvars**

В Ansible область видимости переменных ограничивается хостами. Если объявить переменную в секции vars опе- рации, она будет определена для набора хостов в этой операции. Но на самом деле Ansible создаст копию этой переменной для каждого хоста в группе. Иногда задача, запущенная на одном хосте, требует значения переменной, определяемого на другом хосте. Решить проблему можно с помощью переменной hostvars. Это словарь, содержащий все переменные, объявленные на всех хостах, ключа- ми которого являются имена хостов, как они заданы в реестре Ansible. Если Ansible еще не собрала фактов о хосте, тогда вы не сможете полу- чить доступа к его фактам с использованием переменной hostvars.
```
{{ hostvars['db.example.com'].ansible_eth1.ipv4.address }}
```
**inventory_hostname**

inventory_hostname – это имя текущего хоста, как оно задано в реестре Ansible. Если вы определили псевдоним для хоста, тогда это – псевдоним
```
- debug: var=hostvars[inventory_hostname]
```
**groups**

groups может пригодиться для доступа к переменным, определенным для группы хостов. 
```
{% for host in groups.web %}
  server {{ hostvars[host].inventory_hostname }} \
  {{ hostvars[host].ansible_default_ipv4.address }}:80
{% endfor %}
```
С помощью переменной groups в шаблоне файла конфигурации можно перебирать хосты в группе, используя только имя группы, или изменять хосты в группе, не изменяя шаблон файла конфигурации.

**Установка переменных из командной строки**

Переменные, установленные передачей параметра -e var=value команде ansible-playbook, имеют наивысший приоритет и могут заменять ранее определенные переменные.
```
ansible-playbook example.yml -e greeting=hiya
```
**Приоритет**

1. Значения командной строки (например, -u my_user; это не пере- менные).
2. Значения по умолчанию в ролях (определяются в role/defaults/ main.yml).
3. Переменные, определяемые в реестре или в сценарии для групп хостов.
4. Секция group_vars/all в реестре.
5. Секция group_vars/all в сценарии.
6. Секция group_vars/* в реестре.
7. Секция group_vars/* в сценарии.
8. Переменные,определяемые в реестре или в сценарии для хостов.
9. Секция host_vars/* в реестре.
10. Секция host_vars/* в сценарии.
11. Факты хостов / кешированные факты из set_facts.
12. Переменные операций.
13. Секция vars_prompt в операции.
14. Секция vars_files в операции.
15. Переменные ролей (определяемые в файле role/vars/main.yml).
16. Блочные переменные (только для задач в блоке).
17. Переменные задач (только для задач).
18. Секция include_vars.
19. Факты, возвращаемые модулем set_facts / зарегистрированные переменные.
20. Параметры ролей (и include_role).
21. Подключаемые параметры.
22. Дополнительные переменные (например, -e "user=my_user").

**Установка большого количества пакетов**
```
apt:
  update_cache: true
  cache_valid_time: 3600
  pkg:
    - acl
    - git
```
Когда устанавливается несколько пакетов, Ansible передает весь список модулю **apt**, а модуль вызовет программу apt только один раз, тоже передав ей весь список устанавливаемых пакетов целиком. Модуль apt способен обрабатывать такие списки.

Вызывая модуль apt в Ansible, ему необходимо передать аргумент **update_cache: true**, чтобы обеспечить поддержание локального кеша apt в актуальном состоянии

Обновление кеша занимает некоторое время, поэтому, чтобы избежать ненужных затрат времени на обновление кеша, можно передать модулю аргумент **cache_valid_time**.

**Cоставные аргументы**

Подход на основе словарей также очень удобно использовать для вызова модулей, принимающих составные аргументы. Составной аргумент – это аргумент, включающий список или словарь. Хорошим примером модуля с составными аргументами может служить модуль uri, который посылает веб-запросы.
```
- name: Login to a form based webpage
  uri:
  url: 'https://your.form.based.auth.example.com/login.php'
  method: POST
  body_format: form-urlencoded
  body:
    name: your_username
    password: 'your_password'
    enter: Sign in
  status_code: 302
register: login
```
Передача аргументов в виде словарей вместо строк – широко распространенная практика, позволяющая избежать ошибок с пробелами, которые могут возникнуть при передаче необязательных аргументов, и она очень хорошо зарекомендовала себя при работе с системами управления версиями.

## Отладка сценариев Ansible
**Информативные сообщения об ошибках**
```
[defaults]
stdout_callback = debug

stdout_callback = yaml
```
ansible с аргументом -vvvv - для отладки
```
ansible web -vvvv -m ping
```
**Интерактивный отладчик сценариев**
```
- name: deploy mezzanine on web
  hosts: web
  debugger: always - Включить или отключить отладчик для конкретной операции, роли, блока или задачи можно с помощью ключевого слова debugger
```
Ansible запустит отладчик, и вы сможете выполнять отдельные шаги в сценарии, вводя **c** (continue – продолжить):

Вывод значений переменных – одна из самых полезных возможностей, однако отладчик позволяет также изменять переменные и аргументы задач, потерпевших неудачу

**Модуль assert** завершает сценарий с сообщением об ошибке при невыполнении заданного условия.
```
assert:
that: ansible_enp0s3 is defined
```
**Проверка сценария перед запуском** - При использовании этих флагов сценарий не запускается.
- Проверка синтаксиса - --syntax-check
```
ansible-playbook --syntax-check playbook.yml
```
- Список хостов - --list-hosts
```
ansible-playbook --list-hosts playbook.yml
```
- Список задач - --list-tasks
```
ansible-playbook --list-tasks playbook.yml
```
- Режим проверки - Флаги -C и --check запускают Ansible в режиме проверки - известном как dry run – сухой прогон
```
ansible-playbook -C playbook.yml
ansible-playbook --check playbook.yml
```
Модули, используемые в сценарии, должны поддерживать режим проверки, иначе проверка будет терпеть неудачу.
- Вывод изменений в файлах - Флаги -D и -diff выводят информацию о любых изменениях, сделанных в файлах на удаленной машине
```
ansible-playbook -D --check playbook.yml
ansible-playbook --diff --check playbook.yml
```
Если Ansible внесет изменения в какой-то файл, то она покажет их в формате .diff
- Теги - Ansible позволяет добавлять теги к задачам, ролям и операциям.

Используя флаг -t имена_тегов или --tags имена_тегов, можно потребовать от Ansible выполнить только операции и задачи, отмеченные определенными тегами, а добавив флаг --skip-tags – пропустить опера- ции и задачи
```
ansible-playbook -t nxinx playbook.yml
ansible-playbook --tags=xinx,database playbook.yml
ansible-playbook --skip-tags=mezzanine playbook.yml
```
**Ограничение обслуживаемых хостов**

Чтобы ограничить список хостов, на которых будет выполняться сценарий, можно использовать флаг --limit. Флаг --limit ограничивает круг хостов, на которых будет выполняться сценарий в соответствии с указанным выражением. 
```
ansible-playbook -vv --limit db playbook.yml
```
## Роли: масштабирование сценариев
Роли в Ansible – это основной механизм деления сценария на отдельные файлы. Они упрощают написание сложных сценариев и их повторное использование. Роли обеспечивают возможность структурирования и не содержат никаких данных, специфичных для конкретной машины, поэтому ими можно делиться с коллегами, реализующими управление своими серверами и комбинирующими роли в своих собственных сценариях.

Базовая структура роли:
```
defaults/ - Переменные по умолчанию, которые можно переопределить
files/ - Содержит файлы и сценарии для выгрузки на хосты
handlers/ - действия, которые должны выполняться при получении уведомле- ний об изменениях.
meta/ - Информация о роли
tasks/ - точка входа для действий, выполняемых ролью
templates/ - Содержит файлы шаблонов Jinja2
vars/ - Переменные, которые обычно не должны переопределяться
```
**Предварительные и заключительные задачи**

Ansible выполняет сценарии в следующем порядке:
- до вызова любых ролей выполняются задачи в секции pre_tasks
- затем выполняются роли в секции roles
- и наконец, после вызова ролей выполняются задачи в секции post_tasks

Когда модуль copy или script вызывается в задаче для роли, Ansible будет искать файлы в каталогах в том порядке, в каком они перечислены ниже, и использовать первый найденный
- ./roles/role_name/files/
- ./roles/role_name/
- ./roles/role_name/tasks/files/
- ./roles/role_name/tasks/
- ./files/
- ./.

**Создание файлов и каталогов ролей с помощью ansible-galaxy**

**ansible-galaxy** - основное назначение – загрузка ролей, которыми поделились члены сообщества Ansible. C его помощью можно сгенерировать начальный набор файлов и каталогов для роли
```
ansible-galaxy init --init-path playbooks/roles web
```
**Зависимые роли**

Ansible поддерживает возможность определения зависимостей меж- ду ролями для подобных случаев. Определяя роль, можно указать, что она зависит от одной или нескольких других ролей, а Ansible позаботится о том, чтобы зависимые роли выполнялись первыми.

Укажем, что роль web зависит от роли ntp, создав файл roles/web/meta/ main.yml и добавив в него роль ntp
```
dependencies:
  - { role: ntp, ntp_server=ntp.ubuntu.com }
```
**Ansible Galaxy** - то хранилище ролей Ansible с открытым исходным кодом, пополняемое членами сообще- ства Ansible. Сами роли хранятся на GitHub. ansible-galaxy – инструмент интерфейса командной строки.
```
ansible-galaxy install oefenweb.ntp - Установка роли
ansible-galaxy list - Вывод списка установленных ролей
ansible-galaxy remove oefenweb.ntp - Удаление роли
```

## Сложные сценарии
**Решение проблем с неидемпотентными командами**

Как быть, если нет модуля с эквивалентными командами?
- Решить эту проблему помогут выражения changed_when и failed_when, используемые в Ansible для обнаружения изменения состояния или ошибок.
- Можно добавить выражение changed_when, отыскивающее подстроку "Creating tables" в возвращаемом значении out
```
changed_when: '"Creating tables" in result.out'
```
мы можем убедиться в присутствии переменной result.out
```
changed_when: result.out is defined and "Creating tables" in result.out
```
**Фильтры**
- Фильтр default – один из самых полезных.
```
host: "{{ database_host | default('localhost') }}"
```
- Фильтры для зарегистрированных переменных
  - failed - True, если задача завершилась неудачей 
  - changed - True, если задача выполнила изменения
  - success - True, если задача завершилась успешно
  - skipped - True, если задача была пропущена
```
failed_when: result|failed
```
- Фильтры для путей к файлам
  - basename - Базовое имя файла
  - dirname - Путь к файлу или каталогу
  - expanduser - Путь к файлу со знаком ~, обозначающим путь к домашнему каталогу
  - realpath - Канонический путь к файлу, разрешает символические ссылки

Фильтр basename дает возможность получить имя файла index.html, выделив его из полного пути

- Создание собственного фильтра
  - В каталог ~/.ansible/plugins/filter или /usr/share/ansible/ plugins/filter можно установить свои плагины фильтров.
 
**Подстановки**

Ansible поддерживает функции подстановки, позволяющие читать настройки из разных источников, а затем использовать их в сценариях и шаблонах.
```
ansible-doc -t lookup -l - полный список функций подстановки
```
**Сложные циклы**

C помощью ключевого слова until можно повторять задачу снова и снова, пока она не завершится с признаком успеха:
```
register: maven_download
until: maven_download is success
retries: 5
delay: 3
```
**Плагины with_***
- with_items - Список - Цикл по списку элементов
- with_lines - Команда для выполнения - Цикл по строкам вывода команды
- with_fileglob - Шаблон поиска - Цикл по именам файлов
- with_first_found - Список путей - Первый существующий файл
- with_dict - Словарь - Цикл по элементам словаря
- with_indexed_items - Список - Одна итерация
- with_nested - Список - Вложенный цикл
- with_random_choice - Список - Одна итерация
- with_subelements - Список словарей - Вложенный цикл
- with_flattened - Список списков - Цикл по всем элементам вложенных списков
- with_sequence - Последовательность целых чисел - Цикл по последовательности
- with_together - Список списков - Цикл по элементам объединенного списка
- with_inventory_hostnames - Шаблон хоста - Цикл по хостам, соответствующим шаблону



