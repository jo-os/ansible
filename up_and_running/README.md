
# Ansible: Up and Running

- Откуда взялось название «Ansible»?

Название заимствовано из области научной фантастики. Ansible – это устройство связи, способное передавать информацию быстрее скорости света. Майкл ДеХаан, сооснователь проек- та, позаимствовал название Ansible из книги Орсона Скотта Карда «Игра Эндера».

### Ansible: область применения
- Ansible часто описывают как инструмент управления конфигурациями - принимаем как описание состояния серверов в некотором виде, а затем применение специальных средств для приведения серверов в это состояние. Ansible предоставляет предметно-ориентированный язык (Domain Specific Language, DSL), который используется для описания состояний серверов.
- Подготовка и наполнение новых серверов - подразумевается развертывание новых экземпляров виртуальной машины или облачных служб «программное обеспечение как услуга». Ansible охватывает и эту область, предоставляя несколько модулей поддержки облаков.
## Какие преимущества дает Ansible?
- Простота - Разработчики стремились максимально упростить процесс установ- ки и освоение Ansible
  - Простота синтаксиса - Фактически синтаксис сценариев Ansible основан на YAML, языке описания данных, который создавался специально, чтобы легко восприниматься человеком.
  - Простота аудита - можно легко получить список всех действий и вовлеченных хостов - ansible-playbook --check
  - Практически ничего не нужно устанавливать на удаленных хостаx - Linux должна быть установлена поддержка SSH и Python, Windows должен быть включен WinRM
  - Возможность масштабирования вниз - простое должно оставаться простым, а сложное – возможным
  - Простота распространения - Основной единицей повторного использования в сообществе Ansible в настоящее время является коллекция
  - Простота абстракций - Ansible работает с простыми абстракциями системных ресурсов, таких как файлы, каталоги, пользователи, группы, службы, пакеты и веб-сервисы
  - Выполнение задач сверху вниз - Модули Ansible устроены так, что единственный запуск сценария Ansible сразу приводит каждый сервер в желаемое состояние
 
- Широта возможностей - Абстракции высокого уров- ня, предоставляемые Ansible (например, роли), дают возможность устанавливать и настраивать программное обеспечение быстрее и по- тенциально безопаснее.
  - Встроенные модули - сильной стороной является набор встроенных модулей - модули Ansible несут декларативную функцию и используются для описания требуемого состояния серверов.
  - Использование технологии принудительной настройки - Принудительная настройка дает важное преимущество – вы контролируете время обновления серверов.
  - Многоуровневая оркестрация - Технология принудительной настройки позволяет также реализовать с помощью Ansible многоуровневую оркестрацию – управление отдельными группами компьютеров для выполнения различных операций, таких как обновление ПО.
  - Отсутствие ведущего узла - Ansible официально поддерживает особый режим, называемый ansible-pull, в котором сценарии извлекаются из репозитория. Ansible не нуждается в ведущем узле.
  - Поддержка плагинов - Значительная часть функциональности Ansible реализована в виде подключаемых модулей – плагинов, из которых наиболее часто используются плагины Lookup и Filter. Плагины расширяют базовые возможности Ansible логикой и функциями.
  - Настоящая масштабируемость - Крупные предприятия успешно используют Ansible для настройки десятков тысяч узлов и отлично поддерживают окружения, в которых серверы появляются и исчезают динамически.

- Защищенность - Автоматизация с помощью Ansible помогает повысить защищенность системы до базовых уровней безопасности и стандартов соответствия.
  - Самодокументирующийся код - сценарии всегда содержат актуальные инструкции, поскольку сами являются выполняемым кодом
  - Воспроизводимость - тестирование десятым этажом
  - Эквивалентность создаваемых окружений - Ansible поддерживает определенный способ организации контента, помогающий определить конфигурацию на надлежащем уровне.
  - Шифрование переменных - ansible-vault
  - Защищенный транспорт - Ansible просто использует Secure Shell (SSH) для Linux и WinRM для Windows.
  - Идемпотентность - Идемпотентность – заме- чательное свойство и означает, что сценарий Ansible можно применить к одному и тому же серверу много раз без всякого ущерба для конфи- гурации последнего.
  - Отсутствие демонов - В Ansible нет агента, прослушивающего некоторый порт.
 
### ansible.cfg
ansible.cfg - определяет местоположение файла реестра (inventory) и параметры, влияющие на работу Ansible, например на форматирование вывода.

Где лучше хранить файл ansible.cfg?
- файл, указанный в переменной окружения ANSIBLE_ CONFIG;
- ./ansible.cfg (ansible.cfg в текущем каталоге);
- ~/.ansible.cfg(.ansible.cfg в вашем домашнем каталоге);
- /etc/ansible/ansible.cfg(Linux)или/usr/local/etc/ansible/ansible.cfg

С настройками по умолчанию можно запускать Ansible без ключа –i с именем хоста:
```
ansible testserver -m ping
```
Произвольные команды можно выполнять с помощью модуля command. При запуске модуля необходимо указать аргумент -a с запускаемой командой.
```
ansible testserver -m command -a uptime
```
Модуль command используется настолько часто, что его имя можно опустить в команде
```
ansible testserver -a uptime
```
Если команда в аргументе -a содержит пробелы, то ее необходимо заключить в кавычки
```
ansible testserver -a "tail /var/log/dmesg"
```
Чтобы выполнить команду с привилегиями root, нужно передать параметр –b или --become. В этом случае Ansible выполнит команду от лица (become) пользователя root
```
ansible testserver -b -a "tail /var/log/syslog"
```
## Сценарии: начало
Сценарием (playbook) в Ansible называется файл, описывающий порядок управления конфигурациями.
```
ansible-inventory --graph   - проверим группы в реестре
ansible-playbook webservers.yml - запуск сценария
```
В соответствии с соглашениями Ansible копирует файлы из каталога files, а шаблоны Jinja2 ищет в подкаталоге templates. Поиск в этих ката- логах система Ansible выполняет автоматически.

Сценарии пишутся на YAML - все сценарии Ansible пишутся на YAML. YAML – это язык разметки, напоминающий JSON, но намного проще для восприятия человеком.
```
--- - Начало файла
... - Конец файла
#  - Это комментарий на языке YAML
```
В документах YAML принято оформлять отступы пробелами, чтобы уменьшить количество знаков пунктуации. Мы используем два пробела. А для большей удобочитаемости мы предпочитаем добавлять пробельные строки между задачами в сценарии и между разделами в файлах.
- истина в YAML: true, True, TRUE, yes, Yes, YES, on, On, ON
- ложь в YAML: false, False, FALSE, no, No, NO, off, Off, OFF

**Списки** - в YAML они называются последовательностями. Списки оформляются с помощью отступов и дефиса. Определение каждого списка начинается с его имени и следующего за ним двоеточия. YAML также поддерживает формат встроенных списков. Такие списки заключаются в квадратные скобки, а элементы списка разделяются запятой
```
shows:
- My Fair Lady
- Oklahoma
- The Pirates of Penzance
=
shows: [ My Fair Lady , Oklahoma , The Pirates of Penzance ]
```
**Словари** - в YAML они называются отображениями. YAML также поддерживает формат встроенных словарей. Такие словари заключаются в фигурные скобки, а элементы словаря разделяются запятой.
```
address:
street: Main Street
appt: 742
city: Logan
=
address: { street: Main Street, appt: '742', city: Logan}
```
**Многострочные строковые значения**
YAML поддерживает многострочные строковые значения, распознавая так называемые операторные скобки (| и >) символы, обозначающие начало многострочного текста (+ и –), и даже отступы (от 1 до 9)
```
visiting_address: |+
Department of Computer Science
A.V. Williams Building
University of Maryland
```
**Чистый YAML** - стиль, принятый в YAML можно проанализировать с помощью yamllint
```
- name: Ensure nginx is installed
  package:
    name: nginx
    update_cache: true
```
**Операции** - В любом формате – YAML или JSON – сценарий является списком словарей, или списком операций (play)
- Каждая операция должна содержать переменную hosts, определяющую список хостов или группу
- Воспринимайте операцию как нечто, связывающее хосты и задачи
- Кроме хостов и задач, операции также могут содержать параметры

Три основных параметра
- name - Комментарий, описывающий операцию. Ansible выведет его перед запуском операции.
- become - true, то Ansible выполнит каждую задачу, предварительно приобретя привилегии пользователя, объявленного в параметре become_user
- vars - Список переменных и значений

**Задачи** - tasks - модуль + аргументы = ведет к получению определенного результата

Флаг --start-at-task <имя задачи>,чтобы с помощью ansible-playbook запустить сценарий с середины операции. В этом случае необходимо сослаться на задачу по имени.

**Модули** – это сценарии, которые поставляются с Ansible и производят определенные действия на хосте. Ansible выполняет задачу на хосте, генерируя сценарий, исходя из имени модуля и аргументов, а затем копирует этот сценарий на хост и запускает его.

- package - Устанавливает или удаляет пакеты с использованием диспетчера пакетов хоста.
- copy - Копирует файл с локальной машины на хосты.
- file - Устанавливает атрибуты файла, символической ссылки или каталога
- service - Запускает, останавливает или перезапускает службу.
- template - Создает файл на основе шаблона и копирует его на хосты

**Документация по модулям Ansible**
```
ansible-doc service - вывода документации к модулю service
ansible-doc -l | grep ^apt - найти более конкретные модули, связанные с диспетчером пакетов apt
```
Итог
- **Сценарий** содержит одну или несколько операций.
- **Операции** назначаются неупорядоченному множеству хостов и содержат упорядоченные списки задач.
- Каждая **задача** использует ровно один **модуль**.

**Отслеживание состояния хоста**

Если состояние хоста соответствует значениям аргументов модуля, то Ansible не предпринимает никаких действий и сообщает, что статус **ok**. Если между состоянием хоста и значениями аргументов модуля есть разница, то Ansible вносит изменения в состояние хоста и сообщает, что статус был изменен **(changed)**. Способность Ansible определять изменение состояния можно использовать для выполнения дополни- тельных действий с помощью обработчиков.

**Переменные**
```
vars:
tls_dir: /etc/nginx/ssl/
key_file: nginx.key
cert_file: nginx.crt
```
Каждое значение – это строка. Вообще значением переменной может служить любое выражение, допустимое в YAML. В дополнение к строкам и булевым выражениям можно использовать списки и словари. Для ссылки на переменные используются скобки, например **{{ mustache }}**

**Когда использовать кавычки в строках Ansible**
- Если ссылка на переменную следует сразу после имени модуля, то парсер YAML ошибочно воспримет ее как начало встроенного словаря.
- Похожая ошибка возникает при наличии двоеточия в аргументе. Двоеточие в аргументе сбивает с толку синтаксический анализатор YAM

Ansible поддерживает чередование одинарных и двойных кавычек

**Создание шаблона**

Шаблон – это простой текстовый файл, где с использо- ванием специального синтаксиса определяются переменные, которые должны заменяться фактическими значениями.

Для поддержки шаблонов в Ansible используется механизм Jinja2.

**Циклы**

Если потребуется запустить задачу для каждого элемента из списка, то для этого можно использовать цикл loop. Цикл выполняет задачу несколько раз, каждый раз заменяя элемент item разными значениями из указанного списка
```
- name: Copy TLS files
  copy:
    src: "{{ item }}"
    dest: "{{ tls_dir }}"
    mode: '0600'
  loop:
    - "{{ key_file }}"
    - "{{ cert_file }}"

```
**Обработчики**

Обработчики – это одна из форм условного выполнения, поддерживаемых в Ansible. Обработчик схож с задачей, но запускается только после получения уведомления от задачи.
```
notify: Restart nginx
```
Добавляем инструкцию notify в каждую задачу, чтобы обеспечить перезапуск NGINX, если выполняется одно из условий.

**Несколько фактов об обработчиках, которые необходимо помнить**
- Обработчики обычно выполняются после завершения всех задач и только один раз, даже если было получено несколько уведомлений. Чтобы запустить обработчик в середине операции, нужно добавить следующие две строки:
```
- name: Restart nginx
  meta: flush_handlers
```
- Если сценарий содержит несколько обработчиков, то они всегда выполняются в порядке следования в разделе handlers, а не в порядке поступления уведомлений.
- В официальной документации Ansible говорится, что обработчики в основном используются для перезапуска служб и перезагрузки. 

**Проверка**

**ansible-lint** – это инструмент на языке Python, помогающий находить потенциальные проблемы в сценариях.

Провека синтаксиса:
```
ansible-playbook --syntax-check webservers-tls.yml
ansible-lint webservers-tls.yml
yamllint webservers-tls.yml
```

## Реестр: описание серверов

Реестр в простейшем виде – это список имен хостов, перечисленных через запятую
```
ansible all -i 'localhost,' -a date
```
Группа хостов, данными о которых располагает Ansible, называется реестром (inventory)

**Реестр Ansible** – очень гибкий объект: это может быть текстовый файл, каталог или выполняемый файл, причем некоторые выполняемые файлы поставляются в виде плагинов. Плагины поддержки реестра позволяют указать источник данных, например поставщика облачных услуг, для составления реестра.

**Файл реестра**

Самый простой способ описать имеющиеся хосты – перечислить их в текстовом файле, который принято называть файлом реестра хостов. В простейшем случае реестр – это файл host

**Поведенческие параметры хостов в реестре**

В файле реестра Ansible можно явно указать порт, к которому будет подключаться SSH-клиент системы Ansible. В Ansible эти переменные называются **поведенческими параметрами**
- ansible_host -  Имя хоста Имя хоста или IP-адрес
- ansible_port -  22 Порт для подключения по протоколу SSH
- ansible_user - $USER Пользователь для подключения по прото- колу SSH
- ansible_password (нет) Пароль для подключения по протоколу SSH
- ansible_connection - smart Как Ansible будет подключаться к хосту
- ansible_ssh_private_key_file - (нет) - Закрытый SSH-ключ для аутентификации по протоколу SSH
- ansible_shell_type - sh - Командная оболочка для выполнения команд
- ansible_python_interpreter - /usr/bin/python - Путь к интерпретатору Python на хосте
- ansible_*_interpreter - (нет) - Аналоги ansible_python_interpreter для других языков

- **ansible_connection** - Ansible поддерживаетнесколькотранспортов–механизмовпод- ключения к хостам. По умолчанию используется транспорт smart. Он проверяет поддержку локальным SSH-клиентом функции Con- trolPersist. Если SSH-клиент поддерживает ее, то Ansible будет ис- пользовать локального SSH-клиента. Если локальный клиент не поддерживает ControlPersist, тогда транспорт smart будет использо- вать библиотеку SSH-клиента на Python с названием Paramiko.
- **ansible_shell_type** - Ansible устанавливает SSH-соединения с удаленными машинами и затем запускает на них сценарии. По умолчанию Ansible считает, что на удаленных машинах используется командная оболочка Bourne Shell, доступная как /bin/sh, и создает параметры команд- ной строки, соответствующие оболочке Bourne Shell.
- **ansible_python_interpreter** - Ansible должна знать местоположение интерпретатора Python на удаленной машине.

**Переопределение значений по умолчанию в поведенческих параметрах**
- Переопределить значения по умолчанию поведенческих параметров можно в секции [defaults] файла ansible.cfg
- ansible_port - remote_port
- ansible_user - remote_user
- ansible_ssh_private_key_file - ssh_private_key_file
- ansible_shell_type - executable

Параметр executable определяет полный путь к используемой командной оболочке на удаленной ма- шине (например, /usr/local/bin/fish). Ansible выбирает имя в конце этого пути (для /usr/local/bin/fish это будет имя fish) и использует его как значение по умолчанию для ansible_shell_type

**Группы**

Ansible автоматически определяет группу all (или *). Она включает все хосты, перечисленные в реестре. Порядок следования групп не имеет значения, главный критерий – удобочитаемость.

**Псевдонимы и порты**
```
[vagrant]
vagrant1 ansible_port=2222
vagrant2 ansible_port=2200
```
Имена vagrant1, vagrant2, vagrant3 – это псевдонимы. Они не настоящие имена серверов, но их удобно использовать для обозначения хостов. Ansible поддерживает синтаксис <hostname>:<port>.

**Группировка групп**

Ansible позволяет также определять группы, состоящие из других групп. 
```
[django:children]
```
**Имена хостов с номерами**
```
[web]
web[1:20].example.com
```
**Переменные хостов и групп**
```
[all:vars]
...
[staging:vars]
...
```
Переменные групп объединяются в секции с именами [<имя группы>:vars].

**Переменные хостов и групп: создание собственных файлов**

Ansible проверяет наличие файлов переменных хостов в каталоге host_vars и файлов переменных групп в каталоге group_vars. Эти каталоги должны находиться в каталоге со сценарием или в каталоге с реестром. Если имеются оба каталога, то каталог со сценарием просматривается первым, а каталог с реестром – вторым.

**Динамический реестр**

Ansible поддерживает функцию динамического реестра, которая позволяет избежать копирования. Если файл реестра отмечен как выполняемый, то Ansible будет интерпретировать его как сценарий динамического реестра и запускать его вместо чтения.

**Вывод списка членов групп**

Команда --list должна поддерживать вывод всех переменных всех хостов.

## Переменные и факты
Ansible не является полноценным языком программирования, но в ней присутствуют некоторые черты, присущие языкам программирования. Одна из таких черт – подстановка переменных.

- Самый простой способ определить переменную – поместить в сценарий секцию vars
- Ansible позволяет также распределить объявления переменных по нескольким файлам, использовав секцию vars_files
- Ansible позволяет определить переменные, связанные с хостами или группами, в файле реестра или в отдельных файлах, находящихся рядом с файлом реестра или сценарием. Файлы и каталоги в подкаталоге group_vars должны иметь имена, совпадающие с именами соответствующих им групп в файле реестра, а файлы в каталоге host_vars – с именами соответствующих им хостов

**Вывод значений переменных**

Модуль debug для вывода произвольного сообщения.
```
- debug: var=myvarname
```
Значения переменных можно объединять в двойных фигурных скоб- ках с помощью оператора тильды ~:
```
- name: Concatenate variables
  debug:
    msg: "The URL is https://{{ server_name ~'.'~ domain_name }}/"
```
**Регистрация переменных**

Все модули в Ansible возвращают результат в формате JSON. Чтобы сохранить этот результат, нужно создать зарегистрированную переменную при вызове модуля с помощью ключевого слова **register**.
```
register: login
```
Чтобы использовать переменную login, мы должны знать тип ее значения. Значением переменных, объявленных с помощью ключевого слова register, всегда является словарь. Простейший способ узнать, какие значения возвращает модуль, – зарегистрировать переменную и вывести ее содержимое с помощью модуля debug.

Иногда бывает желательно как-то обработать вывод задачи, потерпевшей ошибку. Однако если задача потерпела ошибку, то Ansible остановит ее выполнение, не дав возможности получить эту ошибку. Чтобы Ansible не останавливала работу после появления ошибки, можно использовать ключевое слово **ignore_errors**.
```
ignore_errors: true
```
Если вы собираетесь использовать зарегистрированные переменные в своих сценариях, то обязательно узнайте, что возвращается в них в обоих случаях – когда состояние хоста изменяется и когда оно не изменяется

**Факты**

На этапе сбора фактов (GATHERING FACTS) Ansible подключается к хосту и запрашивает у него всю информацию: аппаратную архитектуру, название операционной системы, IP-адреса, объем памяти и диска и др. Получить доступ ко всем этим данным можно через переменную **ansible_facts**. По умолчанию к некоторым фактам Ansible можно также обращаться как к переменным верхнего уровня, добавляя префикс ansible_.
```
ansible_facts.os_family
ansible_facts.distribution
ansible_facts.kernel
```
Ansible осуществляет сбор фактов с помощью специального модуля **setup**
```
ansible ubuntu -m setup   - выведет все факты
```
Ansible собирает большое количество фактов, модуль setup поддерживает параметр **filter**.
```
ansible all -m setup -a 'filter=ansible_all_ipv6_addresses'
```
**Локальные факты**

Ansible поддерживает также дополнительный механизм, позволя- ющий ассоциировать факты с хостом. Разместите один или несколько файлов на хосте в каталоге /etc/ansible/facts.d, и Ansible обнаружит их, если они отвечают любому из следующих требований:
- имеют формат .ini;
- имеют формат JSON;
- являются выполняемыми файлами, не принимающими аргумен- тов, и выводят результат в формате JSON в стандартный вывод.

Эти факты доступны в виде ключей особой переменной **ansible_local**.
```
ansible_local.example.book.title
```
**Использование модуля set_fact для задания новой переменной**

Ansible позволяет устанавливать факты в задачах с помощью модуля **set_fact**.
```
set_fact:
  nginx_state: "{{ ansible_facts.services.nginx.state }}"
```
**Встроенные переменные**

Ansible определяет несколько переменных, всегда доступных в сценариях.
- hostvars - Словарь, ключами которого являются имена хостов Ansible, а значениями – словари, отображающие имена переменных в их значения.
- inventory_hostname - Имя текущего хоста, как оно задано в Ansible.
- inventory_hostname_short - Имя текущего хоста, как оно задано в Ansible, без имени домена
- group_names - Список всех групп, в которые входит текущий хост
- groups - Словарь, ключи которого – имена групп в Ansible, а значения – списки имен хостов
- ansible_check_mode - Логическая переменная = истинное значение, когда сценарий выполняется в режиме проверки
- ansible_play_batch - Логическая переменная = истинное значение, когда сценарий выполняется в тестовом режиме
- ansible_play_hosts - Список имен хостов из реестра, участвующих в текущей операции
- ansible_version - Словарь с информацией о версии Ansible

**hostvars**

В Ansible область видимости переменных ограничивается хостами. Если объявить переменную в секции vars опе- рации, она будет определена для набора хостов в этой операции. Но на самом деле Ansible создаст копию этой переменной для каждого хоста в группе. Иногда задача, запущенная на одном хосте, требует значения переменной, определяемого на другом хосте. Решить проблему можно с помощью переменной hostvars. Это словарь, содержащий все переменные, объявленные на всех хостах, ключа- ми которого являются имена хостов, как они заданы в реестре Ansible. Если Ansible еще не собрала фактов о хосте, тогда вы не сможете полу- чить доступа к его фактам с использованием переменной hostvars.
```
{{ hostvars['db.example.com'].ansible_eth1.ipv4.address }}
```
**inventory_hostname**

inventory_hostname – это имя текущего хоста, как оно задано в реестре Ansible. Если вы определили псевдоним для хоста, тогда это – псевдоним
```
- debug: var=hostvars[inventory_hostname]
```
**groups**

groups может пригодиться для доступа к переменным, определенным для группы хостов. 
```
{% for host in groups.web %}
  server {{ hostvars[host].inventory_hostname }} \
  {{ hostvars[host].ansible_default_ipv4.address }}:80
{% endfor %}
```
С помощью переменной groups в шаблоне файла конфигурации можно перебирать хосты в группе, используя только имя группы, или изменять хосты в группе, не изменяя шаблон файла конфигурации.

**Установка переменных из командной строки**

Переменные, установленные передачей параметра -e var=value команде ansible-playbook, имеют наивысший приоритет и могут заменять ранее определенные переменные.
```
ansible-playbook example.yml -e greeting=hiya
```
**Приоритет**

1. Значения командной строки (например, -u my_user; это не пере- менные).
2. Значения по умолчанию в ролях (определяются в role/defaults/ main.yml).
3. Переменные, определяемые в реестре или в сценарии для групп хостов.
4. Секция group_vars/all в реестре.
5. Секция group_vars/all в сценарии.
6. Секция group_vars/* в реестре.
7. Секция group_vars/* в сценарии.
8. Переменные,определяемые в реестре или в сценарии для хостов.
9. Секция host_vars/* в реестре.
10. Секция host_vars/* в сценарии.
11. Факты хостов / кешированные факты из set_facts.
12. Переменные операций.
13. Секция vars_prompt в операции.
14. Секция vars_files в операции.
15. Переменные ролей (определяемые в файле role/vars/main.yml).
16. Блочные переменные (только для задач в блоке).
17. Переменные задач (только для задач).
18. Секция include_vars.
19. Факты, возвращаемые модулем set_facts / зарегистрированные переменные.
20. Параметры ролей (и include_role).
21. Подключаемые параметры.
22. Дополнительные переменные (например, -e "user=my_user").


